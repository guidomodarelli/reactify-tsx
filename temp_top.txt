import * as vscode from 'vscode';
import * as ts from 'typescript';
import { ScriptKindResolver } from '../utils/scriptKindResolver';
import { getRangeFromNode } from '../utils/typeScriptRangeUtils';

export type FlipPlanFailureReason = 'not-found' | 'no-else' | 'unsupported';

export interface FlipPlan {
  readonly range: vscode.Range;
  readonly newText: string;
}

export interface FlipPlanSuccess {
  readonly success: true;
  readonly plan: FlipPlan;
}

export interface FlipPlanFailure {
  readonly success: false;
  readonly reason: FlipPlanFailureReason;
}

export type FlipPlanResult = FlipPlanSuccess | FlipPlanFailure;

interface FlippedStatementResult {
  readonly guard: ts.IfStatement;
  readonly trailingStatements: readonly ts.Statement[];
}

export class IfElseFlipService {
  private readonly scriptKindResolver = new ScriptKindResolver();
  private readonly printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

  public createFlipPlan(document: vscode.TextDocument, selection: vscode.Selection): FlipPlanResult {
    const scriptKind = this.scriptKindResolver.resolve(document);
    const sourceText = document.getText();
    const sourceFile = ts.createSourceFile(
      document.fileName,
      sourceText,
      ts.ScriptTarget.Latest,
      true,
      scriptKind,
    );

    const selectionStart = document.offsetAt(selection.start);
    const selectionEnd = document.offsetAt(selection.end);

    const ifStatement = this.locateIfStatement(sourceFile, selectionStart, selectionEnd);
    if (ifStatement) {
      if (!ifStatement.elseStatement) {
        return { success: false, reason: 'no-else' } satisfies FlipPlanFailure;
      }

      const flipped = this.buildFlippedStatement(ifStatement);
      if (!flipped) {
        return { success: false, reason: 'unsupported' } satisfies FlipPlanFailure;
      }

      const range = getRangeFromNode(document, sourceFile, ifStatement);
      const newText = this.renderFlippedStatement(sourceFile, flipped);

      return {
        success: true,
        plan: {
          range,
          newText,
        },
      } satisfies FlipPlanSuccess;
    }

    const conditionalExpression = this.locateConditionalExpression(sourceFile, selectionStart, selectionEnd);
    if (!conditionalExpression) {
      return { success: false, reason: 'not-found' } satisfies FlipPlanFailure;
    }

    const flippedConditional = this.buildFlippedConditionalExpression(conditionalExpression);
    const range = getRangeFromNode(document, sourceFile, conditionalExpression);
    const newText = this.normalizeJsxSelfClosingSpacing(
      this.printer.printNode(ts.EmitHint.Unspecified, flippedConditional, sourceFile),
    );

    return {
      success: true,
      plan: {
        range,
        newText,
      },
    } satisfies FlipPlanSuccess;
  }

  private locateIfStatement(
    sourceFile: ts.SourceFile,
    selectionStart: number,
    selectionEnd: number,
  ): ts.IfStatement | undefined {
    let bestMatch: ts.IfStatement | undefined;

    const visit = (node: ts.Node) => {
      const nodeStart = node.getStart(sourceFile);
      const nodeEnd = node.getEnd();
      if (selectionStart < nodeStart || selectionEnd > nodeEnd) {
        return;
      }

      if (ts.isIfStatement(node)) {
        bestMatch = node;
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
    return bestMatch;
  }

  private locateConditionalExpression(
    sourceFile: ts.SourceFile,
    selectionStart: number,
    selectionEnd: number,
  ): ts.ConditionalExpression | undefined {
    let bestMatch: ts.ConditionalExpression | undefined;

    const visit = (node: ts.Node) => {
      const nodeStart = node.getStart(sourceFile);
      const nodeEnd = node.getEnd();
      if (selectionStart < nodeStart || selectionEnd > nodeEnd) {
        return;
      }

      if (ts.isConditionalExpression(node)) {
        bestMatch = node;
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
    return bestMatch;
  }

  private buildFlippedStatement(ifStatement: ts.IfStatement): FlippedStatementResult | undefined {
    const { elseStatement } = ifStatement;
    if (!elseStatement) {
      return undefined;
    }

    const negatedCondition = this.negateExpression(ifStatement.expression);
    const preparedThen = this.prepareThenStatement(elseStatement);
    const preparedElse = this.prepareElseStatement(ifStatement.thenStatement);

    if (this.shouldDropElseBranch(elseStatement)) {
      return {
        guard: ts.factory.createIfStatement(negatedCondition, preparedThen, undefined),
        trailingStatements: this.toStatementList(preparedElse),
      } satisfies FlippedStatementResult;
    }

    return {
      guard: ts.factory.createIfStatement(negatedCondition, preparedThen, preparedElse),
      trailingStatements: [],
    } satisfies FlippedStatementResult;
  }

  private renderFlippedStatement(sourceFile: ts.SourceFile, flipped: FlippedStatementResult): string {
    const guardText = this.normalizeJsxSelfClosingSpacing(
      this.normalizePrintedIfStatement(
        this.printer.printNode(ts.EmitHint.Unspecified, flipped.guard, sourceFile),
      ),
    );

    if (flipped.trailingStatements.length === 0) {
      return guardText;
    }

    const trailingText = flipped.trailingStatements
      .map((statement) =>
        this.normalizeJsxSelfClosingSpacing(
          this.printer.printNode(ts.EmitHint.Unspecified, statement, sourceFile),
        ),
      )
      .join('\n\n');

    return `${guardText}\n\n${trailingText}`;
  }

  private buildFlippedConditionalExpression(
    expression: ts.ConditionalExpression,
  ): ts.ConditionalExpression {
    const negatedCondition = this.negateExpression(expression.condition);

    return ts.factory.createConditionalExpression(
      negatedCondition,
      ts.factory.createToken(ts.SyntaxKind.QuestionToken),
      expression.whenFalse,
      ts.factory.createToken(ts.SyntaxKind.ColonToken),
      expression.whenTrue,
    );
  }

  private prepareThenStatement(statement: ts.Statement): ts.Statement {
